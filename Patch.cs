using HarmonyLib;
using SandBox.GauntletUI.AutoGenerated;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime;
using TaleWorlds.Core;
using TaleWorlds.Engine;
using TaleWorlds.Library;
using TaleWorlds.MountAndBlade;
using static TaleWorlds.MountAndBlade.Mission;

namespace CustomPatches
{
	[HarmonyPatch(typeof(Mission))]
	internal static class Patch
	{
		[HarmonyTranspiler]
		[HarmonyPatch("MissileHitCallback")]
		internal static IEnumerable<CodeInstruction> MissileHitCallback(IEnumerable<CodeInstruction> instructions)
		{
			var list = new List<CodeInstruction>(instructions);
			for (int i = 0; i < list.Count; i++)
			{
				// 0    ldfld System.Int32 TaleWorlds.MountAndBlade.CombatLogData::ModifiedDamage
				// 1    sub NULL
				// 2    stfld System.Int32 TaleWorlds.MountAndBlade.CombatLogData::InflictedDamage
				// 3 -- ldarg.2 NULL [Label62, Label63]
				//   ++ ldloca.s 25 (System.Boolean) [Label62, Label63]
				//   ++ ldarg.s 10
				//   ++ ldarg.s 11
				//   ++ ldloca.s 26 (TaleWorlds.MountAndBlade.Blow)
				//   ++ ldloca.s 1 (TaleWorlds.MountAndBlade.MissionWeapon)
				//   ++ ldarga.s 9
				//   ++ call static System.Void CustomPatches.Patch::HandlePierce(...)
				//   ++ ldarg.2 NULL
				// 4    call System.Boolean TaleWorlds.MountAndBlade.AttackCollisionData::get_IsColliderAgent()
				if (list[i].opcode == OpCodes.Ldfld && list[i].operand is FieldInfo fi0 && fi0.Name == "ModifiedDamage"
					&& list[i + 1].opcode == OpCodes.Sub
					&& list[i + 2].opcode == OpCodes.Stfld && list[i + 2].operand is FieldInfo fi1 && fi1.Name == "InflictedDamage"
					&& list[i + 3].opcode == OpCodes.Ldarg_2
					&& list[i + 4].opcode == OpCodes.Call && list[i + 4].operand is MethodBase mb && mb.Name == "get_IsColliderAgent")
				{
					//ldloca.s 25 (System.Boolean) [Label62, Label63]
					list[i + 3].opcode = OpCodes.Ldloca_S;
					list[i + 3].operand = 25;
					//ldarg.s 10
					list.Insert(i++ + 4, new CodeInstruction(OpCodes.Ldarg_S, 10));
					//ldarg.s 11
					list.Insert(i++ + 4, new CodeInstruction(OpCodes.Ldarg_S, 11));
					//ldloca.s 26 (TaleWorlds.MountAndBlade.Blow)
					list.Insert(i++ + 4, new CodeInstruction(OpCodes.Ldloca_S, 26));
					//ldloca.s 1 (TaleWorlds.MountAndBlade.MissionWeapon)
					list.Insert(i++ + 4, new CodeInstruction(OpCodes.Ldloca_S, 1));
					//ldarga.s 9
					list.Insert(i++ + 4, new CodeInstruction(OpCodes.Ldarga_S, 9));
					//call static System.Void CustomPatches.Patch::HandlePierce(...)
					list.Insert(i++ + 4, new CodeInstruction(OpCodes.Call, AccessTools.Method(typeof(Patch), nameof(Patch.HandlePierce))));
					//ldarg.2 NULL
					list.Insert(i++ + 4, new CodeInstruction(OpCodes.Ldarg_2));
				}
			}
			return list;
		}

		// Missile pierce handling
		internal static void HandlePierce(ref bool pierce, Agent attacker, Agent victim, ref Blow blow, ref MissionWeapon attackerWeapon, ref int numDamagedAgents)
		{
			// DONE inject between #144 and #145
			// DONE check if player and player only is set (requires Agent attacker)
			// DONE (better to also give Agent victim)
			// DONE check weapon type (requires MissionWeapon attackerWeapon)
			// DONE reduce damage on subsequent hits (requires Blow blow & int numDamagedAgents)
			// DONE modify flag
			// DONE check inflictedDmg > percentage for pass through armor

			Helper.Message($"--- Plonk!" +
				$"\n'{attacker?.Name}' '{victim?.Name}' '{attackerWeapon.CurrentUsageItem?.WeaponClass}' #{numDamagedAgents}" +
				$"\nBefore: {pierce} '{blow.InflictedDamage} / {blow.AbsorbedByArmor} ({blow.InflictedDamage / (blow.InflictedDamage + blow.AbsorbedByArmor)})'", 
				false, Colors.White);

			// already is piercing, so likely handled otherwise
			if (pierce)
				return;
			// already hit 3 enemies
			if (numDamagedAgents >= 3)
				return;
			// making sure CurrentUsageItem is not null
			if (attackerWeapon.CurrentUsageItem == null)
				return;

			// get settings
			var settings = CustomPatches.Settings;

			// check if only player is allowed to pierce using missiles
			if (settings.OnlyPlayerMissilesPierce && attacker.IsAIControlled)
				return;

			// check weapon type and get settings values
			double damageRetained, ratioRequiredCutThroughArmor;
			switch (attackerWeapon.CurrentUsageItem.WeaponClass)
			{
				case WeaponClass.Arrow:
					if (!settings.EnableArrowPierce)
						return;

					damageRetained = settings.ArrowPierceDamageRetained;
					ratioRequiredCutThroughArmor = settings.ArrowPierceRatioRequiredThroughArmor;
					break;

				case WeaponClass.Bolt:
					if (!settings.EnableBoltPierce)
						return;

					damageRetained = settings.BoltPierceDamageRetained;
					ratioRequiredCutThroughArmor = settings.BoltPierceRatioRequiredThroughArmor;
					break;

				case WeaponClass.Javelin:
					if (!settings.EnableJavelinPierce)
						return;

					damageRetained = settings.JavelinPierceDamageRetained;
					ratioRequiredCutThroughArmor = settings.JavelinPierceRatioRequiredThroughArmor;
					break;

				//case WeaponClass.Stone:
				//case WeaponClass.Boulder:
				//case WeaponClass.ThrowingAxe:
				//case WeaponClass.ThrowingKnife:
				//case WeaponClass.Cartridge:
				//case WeaponClass.Bow:
				//case WeaponClass.Crossbow:
				//case WeaponClass.Pistol:
				//case WeaponClass.Musket:
				default:
					//Helper.Message($"{attackerWeapon.CurrentUsageItem.WeaponClass} go plonk...", false, Colors.White, false);
					return;
			}

			// reduce damage for each target passed through
			if (numDamagedAgents > 0)
				blow.InflictedDamage = MathF.Round(blow.InflictedDamage * MathF.Pow(damageRetained, numDamagedAgents));

			// check if damage is zero
			if (blow.InflictedDamage <= 0)
				return;

			// check if it's a killing blow in case that only those allow piercing
			if (settings.PierceOnKillingBlowOnly && victim.Health > blow.InflictedDamage)
				return;

			// check if inflicted damage is below "cut through armor" threshold
			if ((blow.InflictedDamage / (blow.InflictedDamage + blow.AbsorbedByArmor)) < ratioRequiredCutThroughArmor)
				return;

			// set as piercing
			pierce = true;

			Helper.Message($"After:  {pierce} '{blow.InflictedDamage} / {blow.AbsorbedByArmor} ({blow.InflictedDamage / (blow.InflictedDamage + blow.AbsorbedByArmor)})'", 
				false, Colors.White);
		}
	}

#if false
	[HarmonyPatch(typeof(MissionTest))]
	internal static class Patch1
	{
		[HarmonyTranspiler]
		[HarmonyPatch("MissileHitCallback")]
		internal static IEnumerable<CodeInstruction> MissileHitCallback(IEnumerable<CodeInstruction> instructions)
		{
			var list = new List<CodeInstruction>(instructions);

			FileLog.Log("--- PATCH NEW");
			foreach (var instruction in list)
				FileLog.Log($"{instruction}");

			return list;
		}
	}


	public sealed class MissionTest
	{
		private Dictionary<int, Missile> _missiles;
		public bool ForceNoFriendlyFire;
		private MissionMode _missionMode;
		public MissionMode Mode => _missionMode;
		public MissionCombatType CombatType
		{
			get => default;
			set { }
		}
		private List<MissionBehavior> _missionBehaviorList;
		public List<MissionBehavior> MissionBehaviors => _missionBehaviorList;

		private CombatLogData GetAttackCollisionResults(Agent attackerAgent, Agent victimAgent, GameEntity hitObject, float momentumRemaining, in MissionWeapon attackerWeapon, bool crushedThrough, bool cancelDamage, bool crushedThroughWithoutAgentCollision, ref AttackCollisionData attackCollisionData, out WeaponComponentData shieldOnBack, out CombatLogData combatLog)
		{
			shieldOnBack = default;
			combatLog = default;
			return default; 
		}
		private Blow CreateMissileBlow(Agent attackerAgent, in AttackCollisionData collisionData, in MissionWeapon attackerWeapon, Vec3 missilePosition, Vec3 missileStartingPosition)
		{
			return default;
		}
		private void RegisterBlow(Agent attacker, Agent victim, GameEntity realHitEntity, Blow b, ref AttackCollisionData collisionData, in MissionWeapon attackerWeapon, ref CombatLogData combatLogData)
		{ }
		public void MakeSound(int soundIndex, Vec3 position, bool soundCanBePredicted, bool isReliable, int relatedAgent1, int relatedAgent2)
		{ }
		private MatrixFrame CalculateAttachedLocalFrame(in MatrixFrame attachedGlobalFrame, AttackCollisionData collisionData, WeaponComponentData missileWeapon, Agent affectedAgent, GameEntity hitEntity, Vec3 missileMovementVelocity, Vec3 missileRotationSpeed, MatrixFrame shieldGlobalFrame, bool shouldMissilePenetrate)
		{
			return default;
		}
		public void HandleMissileCollisionReaction(int missileIndex, MissileCollisionReaction collisionReaction, MatrixFrame attachLocalFrame, Agent attackerAgent, Agent attachedAgent, bool attachedToShield, sbyte attachedBoneIndex, MissionObject attachedMissionObject, Vec3 bounceBackVelocity, Vec3 bounceBackAngularVelocity, int forcedSpawnIndex)
		{ }

		internal bool MissileHitCallback(out int extraHitParticleIndex, ref AttackCollisionData collisionData, Vec3 missileStartingPosition, Vec3 missilePosition, Vec3 missileAngularVelocity, Vec3 movementVelocity, MatrixFrame attachGlobalFrame, MatrixFrame affectedShieldGlobalFrame, int numDamagedAgents, Agent attacker, Agent victim, GameEntity hitEntity)
		{
			Missile missile = _missiles[collisionData.AffectorWeaponSlotOrMissileIndex];
			MissionWeapon attackerWeapon = missile.Weapon;
			WeaponFlags missileWeaponFlags = attackerWeapon.CurrentUsageItem.WeaponFlags;
			float num = 1f;
			WeaponComponentData shieldOnBack = null;
			MissionGameModels.Current.AgentApplyDamageModel.DecideMissileWeaponFlags(attacker, missile.Weapon, ref missileWeaponFlags);
			extraHitParticleIndex = -1;
			MissileCollisionReaction missileCollisionReaction = MissileCollisionReaction.Invalid;
			bool flag = !GameNetwork.IsSessionActive;
			bool missileHasPhysics = collisionData.MissileHasPhysics;
			PhysicsMaterial fromIndex = PhysicsMaterial.GetFromIndex(collisionData.PhysicsMaterialIndex);
			PhysicsMaterialFlags num2 = (fromIndex.IsValid ? fromIndex.GetFlags() : PhysicsMaterialFlags.None);
			bool flag2 = (missileWeaponFlags & WeaponFlags.AmmoSticksWhenShot) != 0;
			bool flag3 = (num2 & PhysicsMaterialFlags.DontStickMissiles) == 0;
			bool flag4 = (num2 & PhysicsMaterialFlags.AttacksCanPassThrough) != 0;
			MissionObject missionObject = null;
			if (victim == null && hitEntity != null)
			{
				GameEntity gameEntity = hitEntity;
				do
				{
					missionObject = gameEntity.GetFirstScriptOfType<MissionObject>();
					gameEntity = gameEntity.Parent;
				}
				while (missionObject == null && gameEntity != null);
				hitEntity = missionObject?.GameEntity;
			}
			MissileCollisionReaction missileCollisionReaction2 = (flag4 ? MissileCollisionReaction.PassThrough : (missileWeaponFlags.HasAnyFlag(WeaponFlags.Burning) ? MissileCollisionReaction.BecomeInvisible : ((!flag3 || !flag2) ? MissileCollisionReaction.BounceBack : MissileCollisionReaction.Stick)));
			bool flag5 = false;
			bool flag6 = victim != null && victim.CurrentMortalityState == Agent.MortalityState.Invulnerable;
			CombatLogData combatLog;
			if (collisionData.MissileGoneUnderWater || collisionData.MissileGoneOutOfBorder || flag6)
			{
				missileCollisionReaction = MissileCollisionReaction.BecomeInvisible;
			}
			else if (victim == null)
			{
				if (hitEntity != null)
				{
					GetAttackCollisionResults(attacker, victim, hitEntity, num, in attackerWeapon, crushedThrough: false, cancelDamage: false, crushedThroughWithoutAgentCollision: false, ref collisionData, out shieldOnBack, out combatLog);
					Blow b = CreateMissileBlow(attacker, in collisionData, in attackerWeapon, missilePosition, missileStartingPosition);
					RegisterBlow(attacker, null, hitEntity, b, ref collisionData, in attackerWeapon, ref combatLog);
				}
				missileCollisionReaction = missileCollisionReaction2;
			}
			else if (collisionData.AttackBlockedWithShield)
			{
				GetAttackCollisionResults(attacker, victim, hitEntity, num, in attackerWeapon, crushedThrough: false, cancelDamage: false, crushedThroughWithoutAgentCollision: false, ref collisionData, out shieldOnBack, out combatLog);
				if (!collisionData.IsShieldBroken)
				{
					MakeSound(ItemPhysicsSoundContainer.SoundCodePhysicsArrowlikeStone, collisionData.CollisionGlobalPosition, soundCanBePredicted: false, isReliable: false, -1, -1);
				}
				bool flag7 = false;
				if (missileWeaponFlags.HasAnyFlag(WeaponFlags.CanPenetrateShield))
				{
					if (!collisionData.IsShieldBroken)
					{
						EquipmentIndex wieldedItemIndex = victim.GetWieldedItemIndex(Agent.HandIndex.OffHand);
						if ((float)collisionData.InflictedDamage > ManagedParameters.Instance.GetManagedParameter(ManagedParametersEnum.ShieldPenetrationOffset) + ManagedParameters.Instance.GetManagedParameter(ManagedParametersEnum.ShieldPenetrationFactor) * (float)victim.Equipment[wieldedItemIndex].GetGetModifiedArmorForCurrentUsage())
						{
							flag7 = true;
						}
					}
					else
					{
						flag7 = true;
					}
				}
				if (flag7)
				{
					num *= 0.4f + MBRandom.RandomFloat * 0.2f;
					missileCollisionReaction = MissileCollisionReaction.PassThrough;
				}
				else
				{
					missileCollisionReaction = (collisionData.IsShieldBroken ? MissileCollisionReaction.BecomeInvisible : missileCollisionReaction2);
				}
			}
			else if (collisionData.MissileBlockedWithWeapon)
			{
				GetAttackCollisionResults(attacker, victim, hitEntity, num, in attackerWeapon, crushedThrough: false, cancelDamage: false, crushedThroughWithoutAgentCollision: false, ref collisionData, out shieldOnBack, out combatLog);
				missileCollisionReaction = MissileCollisionReaction.BounceBack;
			}
			else
			{
				if (attacker != null && attacker.IsFriendOf(victim))
				{
					if (ForceNoFriendlyFire)
					{
						flag5 = true;
					}
					else if (!missileHasPhysics)
					{
						if (flag)
						{
							if (attacker.Controller == Agent.ControllerType.AI)
							{
								flag5 = true;
							}
						}
						else if ((MultiplayerOptions.OptionType.FriendlyFireDamageRangedFriendPercent.GetIntValue() <= 0 && MultiplayerOptions.OptionType.FriendlyFireDamageRangedSelfPercent.GetIntValue() <= 0) || Mode == MissionMode.Duel)
						{
							flag5 = true;
						}
					}
				}
				else if (victim.IsHuman && !attacker.IsEnemyOf(victim))
				{
					flag5 = true;
				}
				else if (flag && attacker != null && attacker.Controller == Agent.ControllerType.AI && victim.RiderAgent != null && attacker.IsFriendOf(victim.RiderAgent))
				{
					flag5 = true;
				}
				if (flag5)
				{
					if (flag && attacker == Agent.Main && attacker.IsFriendOf(victim))
					{
						InformationManager.DisplayMessage(new InformationMessage(GameTexts.FindText("ui_you_hit_a_friendly_troop").ToString(), Color.ConvertStringToColor("#D65252FF")));
					}
					missileCollisionReaction = MissileCollisionReaction.BecomeInvisible;
				}
				else
				{
					bool flag8 = (missileWeaponFlags & WeaponFlags.MultiplePenetration) != 0;
					GetAttackCollisionResults(attacker, victim, null, num, in attackerWeapon, crushedThrough: false, cancelDamage: false, crushedThroughWithoutAgentCollision: false, ref collisionData, out shieldOnBack, out combatLog);
					Blow blow = CreateMissileBlow(attacker, in collisionData, in attackerWeapon, missilePosition, missileStartingPosition);
					if (collisionData.IsColliderAgent && flag8 && numDamagedAgents > 0)
					{
						blow.InflictedDamage /= numDamagedAgents;
						blow.SelfInflictedDamage /= numDamagedAgents;
						combatLog.InflictedDamage = blow.InflictedDamage - combatLog.ModifiedDamage;
					}

					Patch.HandlePierce(ref flag8, attacker, victim, ref blow, ref attackerWeapon, ref numDamagedAgents);

					if (collisionData.IsColliderAgent)
					{
						if (MissionGameModels.Current.AgentApplyDamageModel.DecideAgentShrugOffBlow(victim, collisionData, in blow))
						{
							blow.BlowFlag |= BlowFlags.ShrugOff;
						}
						else if (victim.IsHuman)
						{
							Agent mountAgent = victim.MountAgent;
							if (mountAgent != null)
							{
								if (mountAgent.RiderAgent == victim && MissionGameModels.Current.AgentApplyDamageModel.DecideAgentDismountedByBlow(attacker, victim, in collisionData, attackerWeapon.CurrentUsageItem, in blow))
								{
									blow.BlowFlag |= BlowFlags.CanDismount;
								}
							}
							else
							{
								if (MissionGameModels.Current.AgentApplyDamageModel.DecideAgentKnockedBackByBlow(attacker, victim, in collisionData, attackerWeapon.CurrentUsageItem, in blow))
								{
									blow.BlowFlag |= BlowFlags.KnockBack;
								}
								if (MissionGameModels.Current.AgentApplyDamageModel.DecideAgentKnockedDownByBlow(attacker, victim, in collisionData, attackerWeapon.CurrentUsageItem, in blow))
								{
									blow.BlowFlag |= BlowFlags.KnockDown;
								}
							}
						}
					}
					if (victim.State == AgentState.Active)
					{
						RegisterBlow(attacker, victim, null, blow, ref collisionData, in attackerWeapon, ref combatLog);
					}
					extraHitParticleIndex = MissionGameModels.Current.DamageParticleModel.GetMissileAttackParticle(attacker, victim, in blow, in collisionData);
					if (flag8 && numDamagedAgents < 3)
					{
						missileCollisionReaction = MissileCollisionReaction.PassThrough;
					}
					else
					{
						missileCollisionReaction = missileCollisionReaction2;
						if (missileCollisionReaction2 == MissileCollisionReaction.Stick && !collisionData.CollidedWithShieldOnBack)
						{
							bool flag9 = CombatType == MissionCombatType.Combat;
							if (flag9)
							{
								bool flag10 = victim.IsHuman && collisionData.VictimHitBodyPart == BoneBodyPartType.Head;
								flag9 = victim.State != AgentState.Active || !flag10;
							}
							if (flag9)
							{
								float managedParameter = ManagedParameters.Instance.GetManagedParameter(ManagedParametersEnum.MissileMinimumDamageToStick);
								float num3 = 2f * managedParameter;
								if ((float)blow.InflictedDamage < managedParameter && blow.AbsorbedByArmor > num3 && !GameNetwork.IsClientOrReplay)
								{
									missileCollisionReaction = MissileCollisionReaction.BounceBack;
								}
							}
							else
							{
								missileCollisionReaction = MissileCollisionReaction.BecomeInvisible;
							}
						}
					}
				}
			}
			if (collisionData.CollidedWithShieldOnBack && shieldOnBack != null && victim != null && victim.IsMainAgent)
			{
				InformationManager.DisplayMessage(new InformationMessage(GameTexts.FindText("ui_hit_shield_on_back").ToString(), Color.ConvertStringToColor("#FFFFFFFF")));
			}
			MatrixFrame attachLocalFrame;
			if (!collisionData.MissileHasPhysics && missileCollisionReaction == MissileCollisionReaction.Stick)
			{
				attachLocalFrame = CalculateAttachedLocalFrame(in attachGlobalFrame, collisionData, missile.Weapon.CurrentUsageItem, victim, hitEntity, movementVelocity, missileAngularVelocity, affectedShieldGlobalFrame, shouldMissilePenetrate: true);
			}
			else
			{
				attachLocalFrame = attachGlobalFrame;
				attachLocalFrame.origin.z = Math.Max(attachLocalFrame.origin.z, -100f);
				missionObject = null;
			}
			Vec3 velocity = Vec3.Zero;
			Vec3 angularVelocity = Vec3.Zero;
			if (missileCollisionReaction == MissileCollisionReaction.BounceBack)
			{
				WeaponFlags weaponFlags = missileWeaponFlags & WeaponFlags.AmmoBreakOnBounceBackMask;
				if ((weaponFlags == WeaponFlags.AmmoCanBreakOnBounceBack && collisionData.MissileVelocity.Length > ManagedParameters.Instance.GetManagedParameter(ManagedParametersEnum.BreakableProjectileMinimumBreakSpeed)) || weaponFlags == WeaponFlags.AmmoBreaksOnBounceBack)
				{
					missileCollisionReaction = MissileCollisionReaction.BecomeInvisible;
					extraHitParticleIndex = ParticleSystemManager.GetRuntimeIdByName("psys_game_broken_arrow");
				}
				else
				{
					missile.CalculateBounceBackVelocity(missileAngularVelocity, collisionData, out velocity, out angularVelocity);
				}
			}
			HandleMissileCollisionReaction(collisionData.AffectorWeaponSlotOrMissileIndex, missileCollisionReaction, attachLocalFrame, attacker, victim, collisionData.AttackBlockedWithShield, collisionData.CollisionBoneIndex, missionObject, velocity, angularVelocity, -1);
			foreach (MissionBehavior missionBehavior in MissionBehaviors)
			{
				missionBehavior.OnMissileHit(attacker, victim, flag5);
			}
			return missileCollisionReaction != MissileCollisionReaction.PassThrough;
		}
	}



	//[HarmonyPatch(typeof(Mission))]
	//internal static class Patch
	//{
	//	[HarmonyPrefix]
	//	[HarmonyPatch("MissileHitCallback")]
	//	internal static void MissileHitCallback_Prefix(
	//		//out int extraHitParticleIndex, 
	//		ref AttackCollisionData collisionData,
	//		Vec3 missileStartingPosition,
	//		Vec3 missilePosition,
	//		Vec3 missileAngularVelocity,
	//		Vec3 movementVelocity,
	//		MatrixFrame attachGlobalFrame,
	//		MatrixFrame affectedShieldGlobalFrame,
	//		int numDamagedAgents,
	//		Agent attacker,
	//		Agent victim,
	//		GameEntity hitEntity)
	//	{


	//	}

	//	[HarmonyPostfix]
	//	[HarmonyPatch("CreateMissileBlow")]
	//	internal static void CreateMissileBlow_Postfix(Agent attackerAgent, in AttackCollisionData collisionData, in MissionWeapon attackerWeapon, Vec3 missilePosition, Vec3 missileStartingPosition)
	//	{
	//		// reduce damage here?
	//	}
	//}

	//[HarmonyPatch(typeof(SandboxAgentApplyDamageModel))]
	//internal static class Patch_SandboxAgentApplyDamageModel_DecideMissileWeaponFlags
	//{
	//	[HarmonyPostfix]
	//	[HarmonyPatch("DecideMissileWeaponFlags")]
	//	internal static void DecideMissileWeaponFlags_Postfix(
	//		Agent attackerAgent,
	//		MissionWeapon missileWeapon,
	//		ref WeaponFlags missileWeaponFlags)
	//	{
	//		if (missileWeapon.CurrentUsageItem == null)
	//			return;

	//		switch (missileWeapon.CurrentUsageItem.WeaponClass)
	//		{
	//			case WeaponClass.Arrow:
	//				break;
	//			case WeaponClass.Bolt:
	//				break;
	//			case WeaponClass.Javelin:
	//				break;

	//			case WeaponClass.Cartridge:
	//				Helper.Message($"Plonk: {missileWeapon.CurrentUsageItem.WeaponClass}", false, Colors.White);
	//				return;

	//			//case WeaponClass.Stone:
	//			//case WeaponClass.Boulder:
	//			//case WeaponClass.ThrowingAxe:
	//			//case WeaponClass.ThrowingKnife:
	//			//break;

	//			//case WeaponClass.Pistol:
	//			//case WeaponClass.Musket:
	//			//case WeaponClass.Bow:
	//			//case WeaponClass.Crossbow:
	//			default:
	//				break;
	//		}

	//		// Player Only
	//		// Damage retained
	//		// Damage required for armor

	//		//missileWeaponFlags |= WeaponFlags.MultiplePenetration;
	//	}
	//}


	//[HarmonyPatch(typeof(Mission))]
	//internal static class Patch
	//{
	//	[HarmonyPrefix]
	//	[HarmonyPatch("MeleeHitCallback")]
	//	internal static void MeleeHitCallback(Mission __instance)
	//	{
	//		Helper.Message($"MeleeHitCallback");
	//	}

	//	[HarmonyPostfix]
	//	[HarmonyPatch("MissileHitCallback")]
	//	internal static void MissileHitCallback(Mission __instance, ref bool __result, int numDamagedAgents, Agent attacker, Agent victim, GameEntity hitEntity)
	//	{
	//		Helper.Message($"MissileHitCallback {__result} {numDamagedAgents} '{attacker?.Name}' '{victim?.Name}' '{hitEntity?.Name}'", false, Colors.White);
	//	}

	//	[HarmonyPostfix]
	//	[HarmonyPatch("HandleMissileCollisionReaction")]
	//	internal static void HandleMissileCollisionReaction(MissileCollisionReaction collisionReaction)
	//	{
	//		Helper.Message($"HandleMissileCollisionReaction {collisionReaction}", false, Colors.White);
	//	}

	//	[HarmonyTranspiler]
	//	[HarmonyPatch("MissileHitCallback")]
	//	internal static IEnumerable<CodeInstruction> MissileHitCallbackT(IEnumerable<CodeInstruction> instructions)
	//	{
	//		//  0    conv.i8 NULL
	//		//  1    cgt.un NULL
	//		//  2    stloc.s 11(System.Boolean)
	//		//  3 -- dup NULL
	//		//  4    ldc.i4.1 NULL
	//		//  5    and NULL
	//		//  6    ldc.i4.0 NULL
	//		//  7    ceq NULL
	//		//  8    stloc.s 12(System.Boolean)
	//		//  9 -- ldc.i4.8 NULL
	//		// 10 -- and NULL
	//		// 11 -- ldc.i4.0 NULL
	//		// 12 -- cgt.un NULL
	//		//    ++ ldc.i4.1 NULL
	//		// 13    stloc.s 13(System.Boolean)
	//		// 14    ldnull NULL
	//		// 15    stloc.s 14(TaleWorlds.MountAndBlade.MissionObject)

	//		var list = new List<CodeInstruction>(instructions);

	//		//FileLog.Log($"--- 0");
	//		//foreach (var instruction in list)
	//		//	FileLog.Log($"{instruction}");

	//		for (int i = 0; i < list.Count; i++)
	//		{
	//			if (list[i].opcode == OpCodes.Conv_I8
	//				&& list[i + 1].opcode == OpCodes.Cgt_Un
	//				&& list[i + 2].opcode == OpCodes.Stloc_S
	//				&& list[i + 3].opcode == OpCodes.Dup
	//				&& list[i + 4].opcode == OpCodes.Ldc_I4_1
	//				&& list[i + 5].opcode == OpCodes.And
	//				&& list[i + 6].opcode == OpCodes.Ldc_I4_0
	//				&& list[i + 7].opcode == OpCodes.Ceq
	//				&& list[i + 8].opcode == OpCodes.Stloc_S
	//				&& list[i + 9].opcode == OpCodes.Ldc_I4_8
	//				&& list[i + 10].opcode == OpCodes.And
	//				&& list[i + 11].opcode == OpCodes.Ldc_I4_0
	//				&& list[i + 12].opcode == OpCodes.Cgt_Un
	//				&& list[i + 13].opcode == OpCodes.Stloc_S
	//				&& list[i + 14].opcode == OpCodes.Ldnull
	//				&& list[i + 15].opcode == OpCodes.Stloc_S)
	//			{
	//				list.RemoveAt(i-- + 3);
	//				list.RemoveAt(i-- + 9);
	//				list.RemoveAt(i-- + 10);
	//				list.RemoveAt(i-- + 11);
	//				list[i + 12].opcode = OpCodes.Ldc_I4_1;
	//				break;
	//			}
	//		}

	//		//FileLog.Log($"--- 1");
	//		//foreach (var instruction in list)
	//		//	FileLog.Log($"{instruction}");

	//		return list;
	//	}
	//}

	//[HarmonyPatch(typeof(MissionTest))]
	//internal static class Patch1
	//{
	//	[HarmonyTranspiler]
	//	[HarmonyPatch("MissileHitCallback")]
	//	internal static IEnumerable<CodeInstruction> MissileHitCallbackT(IEnumerable<CodeInstruction> instructions)
	//	{
	//		FileLog.Log($"--- 1");
	//		foreach (var instruction in instructions)
	//		{
	//			FileLog.Log($"{instruction}");
	//			yield return instruction;
	//		}
	//	}
	//}

	//[HarmonyPatch(typeof(MissionOrderVM))]
	//internal static class Patch
	//{
	//	[HarmonyPrefix]
	//	[HarmonyPatch("ApplySelectedOrder")]
	//	internal static void Method(MissionOrderVM __instance)
	//	{
	//		Helper.Message($"ApplySelectedOrder {__instance.LastSelectedOrderItem?.TooltipText}");
	//	}
	//}

	//[HarmonyPatch(typeof(MBAgentVisuals))]
	//internal static class PatchMBAgentVisuals
	//{
	//	[HarmonyPostfix]
	//	[HarmonyPatch("SetContourColor")]
	//	internal static void SetContourColor(MBAgentVisuals __instance)
	//	{
	//		Helper.Message($"SetContourColor {__instance.GetEntity()?.Name}");
	//	}
	//}


	//[HarmonyPatch(typeof(OrderTroopPlacer))]
	//internal static class Patch2
	//{
	//	[HarmonyPostfix]
	//	[HarmonyPatch("UpdateFormationDrawingForMovementOrder")]
	//	internal static void Method(bool giveOrder)
	//	{
	//		if (giveOrder)
	//			Helper.Message($"UpdateFormationDrawingForMovementOrder");
	//	}
	//}

	// TaleWorlds.MountAndBlade.Mission
#endif
}
