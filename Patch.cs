using HarmonyLib;
using SandBox.GauntletUI.AutoGenerated;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime;
using TaleWorlds.Core;
using TaleWorlds.Engine;
using TaleWorlds.Library;
using TaleWorlds.MountAndBlade;
using static TaleWorlds.MountAndBlade.Mission;

namespace CustomPatches
{
	[HarmonyPatch(typeof(Mission))]
	internal static class Patch
	{
		[HarmonyTranspiler]
		[HarmonyPatch("MissileHitCallback")]
		internal static IEnumerable<CodeInstruction> MissileHitCallback(IEnumerable<CodeInstruction> instructions)
		{
			var list = new List<CodeInstruction>(instructions);
			for (int i = 0; i < list.Count; i++)
			{
				// 0    ldfld System.Int32 TaleWorlds.MountAndBlade.CombatLogData::ModifiedDamage
				// 1    sub NULL
				// 2    stfld System.Int32 TaleWorlds.MountAndBlade.CombatLogData::InflictedDamage
				// 3 -- ldarg.2 NULL [Label62, Label63]
				//   ++ ldloca.s 25 (System.Boolean) [Label62, Label63]
				//   ++ ldarg.s 10
				//   ++ ldarg.s 11
				//   ++ ldloca.s 26 (TaleWorlds.MountAndBlade.Blow)
				//   ++ ldloca.s 1 (TaleWorlds.MountAndBlade.MissionWeapon)
				//   ++ ldarga.s 9
				//   ++ call static System.Void CustomPatches.Patch::HandlePierce(...)
				//   ++ ldarg.2 NULL
				// 4    call System.Boolean TaleWorlds.MountAndBlade.AttackCollisionData::get_IsColliderAgent()
				if (list[i].opcode == OpCodes.Ldfld && list[i].operand is FieldInfo fi0 && fi0.Name == "ModifiedDamage"
					&& list[i + 1].opcode == OpCodes.Sub
					&& list[i + 2].opcode == OpCodes.Stfld && list[i + 2].operand is FieldInfo fi1 && fi1.Name == "InflictedDamage"
					&& list[i + 3].opcode == OpCodes.Ldarg_2
					&& list[i + 4].opcode == OpCodes.Call && list[i + 4].operand is MethodBase mb && mb.Name == "get_IsColliderAgent")
				{
					//ldloca.s 25 (System.Boolean) [Label62, Label63]
					list[i + 3].opcode = OpCodes.Ldloca_S;
					list[i + 3].operand = 25;
					//ldarg.s 10
					list.Insert(i++ + 4, new CodeInstruction(OpCodes.Ldarg_S, 10));
					//ldarg.s 11
					list.Insert(i++ + 4, new CodeInstruction(OpCodes.Ldarg_S, 11));
					//ldloca.s 26 (TaleWorlds.MountAndBlade.Blow)
					list.Insert(i++ + 4, new CodeInstruction(OpCodes.Ldloca_S, 26));
					//ldloca.s 1 (TaleWorlds.MountAndBlade.MissionWeapon)
					list.Insert(i++ + 4, new CodeInstruction(OpCodes.Ldloca_S, 1));
					//ldarga.s 9
					list.Insert(i++ + 4, new CodeInstruction(OpCodes.Ldarga_S, 9));
					//call static System.Void CustomPatches.Patch::HandlePierce(...)
					list.Insert(i++ + 4, new CodeInstruction(OpCodes.Call, AccessTools.Method(typeof(Patch), nameof(Patch.HandlePierce))));
					//ldarg.2 NULL
					list.Insert(i++ + 4, new CodeInstruction(OpCodes.Ldarg_2));
				}
			}
			return list;
		}

		// Missile pierce handling
		internal static void HandlePierce(ref bool pierce, Agent attacker, Agent victim, ref Blow blow, ref MissionWeapon attackerWeapon, ref int numDamagedAgents)
		{
			//Helper.Message($"--- Plonk!" +
			//	$"\n'{attacker?.Name}' '{victim?.Name}' '{attackerWeapon.CurrentUsageItem?.WeaponClass}' #{numDamagedAgents}" +
			//	$"\nBefore: {pierce} '{blow.InflictedDamage} / {blow.AbsorbedByArmor} ({blow.InflictedDamage / (blow.InflictedDamage + blow.AbsorbedByArmor)})'", 
			//	false, Colors.White);

			// already is piercing, so likely handled otherwise
			if (pierce)
				return;
			// already hit 3 enemies
			if (numDamagedAgents >= 3)
				return;
			// making sure CurrentUsageItem is not null
			if (attackerWeapon.CurrentUsageItem == null)
				return;

			// get settings
			var settings = CustomPatches.Settings;

			// check if only player is allowed to pierce using missiles
			if (settings.OnlyPlayerMissilesPierce && attacker.IsAIControlled)
				return;

			// check weapon type and get settings values
			double damageRetained, ratioRequiredCutThroughArmor;
			switch (attackerWeapon.CurrentUsageItem.WeaponClass)
			{
				case WeaponClass.Arrow:
					if (!settings.EnableArrowPierce)
						return;

					damageRetained = settings.ArrowPierceDamageRetained;
					ratioRequiredCutThroughArmor = settings.ArrowPierceRatioRequiredThroughArmor;
					break;

				case WeaponClass.Bolt:
					if (!settings.EnableBoltPierce)
						return;

					damageRetained = settings.BoltPierceDamageRetained;
					ratioRequiredCutThroughArmor = settings.BoltPierceRatioRequiredThroughArmor;
					break;

				case WeaponClass.Javelin:
					if (!settings.EnableJavelinPierce)
						return;

					damageRetained = settings.JavelinPierceDamageRetained;
					ratioRequiredCutThroughArmor = settings.JavelinPierceRatioRequiredThroughArmor;
					break;

				//case WeaponClass.Stone:
				//case WeaponClass.Boulder:
				//case WeaponClass.ThrowingAxe:
				//case WeaponClass.ThrowingKnife:
				//case WeaponClass.Cartridge:
				//case WeaponClass.Bow:
				//case WeaponClass.Crossbow:
				//case WeaponClass.Pistol:
				//case WeaponClass.Musket:
				default:
					//Helper.Message($"{attackerWeapon.CurrentUsageItem.WeaponClass} go plonk...", false, Colors.White, false);
					return;
			}

			// reduce damage for each target passed through
			if (numDamagedAgents > 0)
				blow.InflictedDamage = MathF.Round(blow.InflictedDamage * MathF.Pow(damageRetained, numDamagedAgents));

			// check if damage is zero
			if (blow.InflictedDamage <= 0)
				return;

			// check if it's a killing blow in case that only those allow piercing
			if (settings.PierceOnKillingBlowOnly && victim.Health > blow.InflictedDamage)
				return;

			// check if inflicted damage is below "cut through armor" threshold
			if ((blow.InflictedDamage / (blow.InflictedDamage + blow.AbsorbedByArmor)) < ratioRequiredCutThroughArmor)
				return;

			// set as piercing
			pierce = true;

			//Helper.Message($"After:  {pierce} '{blow.InflictedDamage} / {blow.AbsorbedByArmor} ({blow.InflictedDamage / (blow.InflictedDamage + blow.AbsorbedByArmor)})'", 
			//	false, Colors.White);
		}
	}
}
